# Architecture

## State
Game state is the data held by the game to describe all the objects inside it. This includes level data, player data,
object data and everything else.

This engine is build around the concept of state. Each module registers a `state` property, which is modified during an
engine `tick` event, and stored during an engine `store` event. These methods are provided by
[JaxWilko\Game\Classes\Engine\Core\Modules\GameModule](../classes/engine/core/modules/GameModule.php).

## Ticks
The system works on distinct ticks. A tick is a unit of time in which events are processed, these can include events
generated by the system such as AI events, as well as player input.

## Engine
The engine is the core of the game system, it handles registering game object and dispatching events across the system.

### Engine Magic

The [Engine](../classes/engine/Engine.php) offers some magic methods.
- `exec*` - Exec methods call [Events::fire](../classes/engine/core/events/Events.php), triggering any callables
registered for that event. These can be registered via `$events->listen('eventName', function () {});`.
- `get*` - Get methods call [Events::fireRetrievable](../classes/engine/core/events/Events.php), allowing for triggered
callables to return a value. These can be registered via `$events->listenRetrievable('eventName', function () {});`.

Within [GameModules](../classes/engine/core/modules/GameModule.php), these can be registered via:
```php
// execMyFunctionName
protected array $emits = [
    'myFunctionName'
];

// getMyRetrievableFunction
protected array $stats = [
    'getMyRetrievableFunction'
];
```

During an application `tick`, the game server is calls multiple of these events, in short it looks like:
```php
$engine->execTick()
    ->execStore();

foreach ($players as $player) {
    $data = $engine->getPlayerData($player);
    // ...
}
```

## Modules
Modules are core game engine objects, they are registered during the initial boot of the engine. During registration,
they are able to listen to Engine events.

### World Module
The world module is responsible for managing the `world` data, this includes the levels and actors.

During the engine `tick` event, the world module processes tick events for each level, which triggers the tick events
for `LAYER_TRIGGERS` & `LAYER_SPRITES` objects.

Due to the engine supporting multiple worker threads, all data is stored by ID, allowing threads to load data from the
store by ID.

#### Levels
Levels are a collection of `WorldObject`s, organised by layers.

The level layers are:
- `LAYER_BACKGROUND`
- `LAYER_BLOCKS`
- `LAYER_PROPS`
- `LAYER_TRIGGERS`
- `LAYER_MARKERS`
- `LAYER_ACTORS`
- `LAYER_SPRITES`
- `LAYER_PROPS_TOP`

##### WorldObjects
A `WorldObject` has 2 `Vector`s, a positional `vector` and a `size`. E.g.
`new WorldObject(new Vector(10, 10), new Vector(32, 64))`.
```
+------------
|           |
|           |
|           |
------------*
+ = vector
* = size (vector + size)
```

All objects that exist within the level extend from `WorldObject`. The base world object is extended with specific
implementations applicable to different level layers, this includes:
- `StaticSpriteObject`
- `StaticTriggerObject`
- `StaticWorldObject`
- `WorldObject`

### Ai Module
The AI module is not very complex, it loads all actors from each `Level`, filters out any that do not implement
`AiActor` and then dispatches the actors `update()` method.

However, as the AI logic is very taxing on the system, it uses the Engine's worker threads to spread the workload.

### Player Module
The Player module is responsible for managing players. It implements methods callable on the engine that allow for
player communications to be processed.

Engine exec methods:
- `addPlayer`
- `removePlayer`
- `controlPlayer`
- `playerMessage`
- `playerSettings`
- `playerUseItem`
- `playerDropItem`
- `playerQuestAction`

Engine get methods:
- `hasPlayer`
- `playerData`

The player module also implements a `tick` event which simply respawns dead players.
